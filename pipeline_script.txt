#!/bin/bash

# defining file paths as variables for simpler use later in the script
fastqdir=/localdisk/data/BPSM/AY21/fastq
Tcongo_genome=/localdisk/data/BPSM/AY21/Tcongo_genome/TriTrypDB-46_TcongolenseIL3000_2019_Genome.fasta.gz
bedfile=/localdisk/data/BPSM/AY21/TriTrypDB-46_TcongolenseIL3000_2019.bed

mkdir fastqc_outputs
for fastq_file in $fastqdir/*fq.gz
 do
 fastqc -o fastqc_outputs $fastq_file 
done

# assessing quality of output data
for fastqc_file in fastqc_outputs/*.zip
 do
 echo -e "\nSee below for summary statistics and fastqc quality metrics that sample ${fastqc_file:15:-11} failed on or where there are warnings."
 echo "Please see the full html report including plots at ${fastqc_file::-4}.html"
 echo -e "If quality is deemed to be insufficient please use the program Trimmomatic to filter poor quality reads and trim poor quality bases."
 echo -e "Please save any trimmed fastq files in the same location with the same name as the original fastq file to overwrite it.\n"
 unzip -q $fastqc_file 
 head ${fastqc_file:15:-4}/fastqc_data.txt
 echo ""
 cat ${fastqc_file:15:-4}/summary.txt | grep "FAIL\|WARN"
done
 

# create bowtie2 index database for the T. congolense reference genome
#bowtie2-build $Tcongo_genome Tcongo_indexed_genome

# iterate over all pairs of fastq files
for fastq_1_file in $fastqdir/*1.fq.gz
do
fastq_2_file=`echo $fastq_1_file | sed 's/_1/_2/'`

# map each pair of reads to the bowtie index database for the T. congolense reference genome 
#bowtie2 -x Tcongo_indexed_genome -q -1 $fastq_1_file -2 $fastq_2_file -S ${fastq_1_file:32:-8}.sam

# convert sam file from bowtie2 output to a bam file
#samtools view -b -S ${fastq_1_file:32:-8}.sam > ${fastq_1_file:32:-8}.bam
#samtools sort ${fastq_1_file:32:-8}.bam -o ${fastq_1_file:32:-8}.sorted.bam
#samtools index ${fastq_1_file:32:-8}.sorted.bam

# count the reads using bedtools multicov. -D means includes duplicate reads
#bedtools multicov -D -bams ${fastq_1_file:32:-8}.sorted.bam -bed $bedfile > ${fastq_1_file:32:-8}.counts

done

# Now need to generate groups from the sample info file.

# Removing old groups 
rm *group.txt
IFS=$'\t'
while read id sample replicate time treatment end1 end2
do
if test $sample == "Clone1" && test $time == "0" 
then echo -e "$id\t$sample\t$replicate\t$time\t$treatment\t$end1\t$end2" >> clone1_0_group.txt
fi
if test $sample == Clone2 && test $time == 0 
then echo -e "$id\t$sample\t$replicate\t$time\t$treatment\t$end1\t$end2" >> clone2_0_group.txt
fi
if test $sample == WT && test $time == 0 
then echo -e "$id\t$sample\t$replicate\t$time\t$treatment\t$end1\t$end2" >> wt_0_group.txt
fi
if test $sample == Clone1 && test $time == 24 && test $treatment == Uninduced
then echo -e "$id\t$sample\t$replicate\t$time\t$treatment\t$end1\t$end2" >> clone1_24_unind_group.txt
fi
if test $sample == Clone2 && test $time == 24 && test $treatment == Uninduced
then echo -e "$id\t$sample\t$replicate\t$time\t$treatment\t$end1\t$end2" >> clone2_24_unind_group.txt
fi
if test $sample == WT && test $time == 24 && test $treatment == Uninduced
then echo -e "$id\t$sample\t$replicate\t$time\t$treatment\t$end1\t$end2" >> wt_24_unind_group.txt
fi
if test $sample == Clone1 && test $time == 48 && test $treatment == Uninduced
then echo -e "$id\t$sample\t$replicate\t$time\t$treatment\t$end1\t$end2" >> clone1_48_unind_group.txt
fi
if test $sample == Clone2 && test $time == 48 && test $treatment == Uninduced
then echo -e "$id\t$sample\t$replicate\t$time\t$treatment\t$end1\t$end2" >> clone2_48_unind_group.txt
fi
if test $sample == WT && test $time == 48 && test $treatment == Uninduced
then echo -e "$id\t$sample\t$replicate\t$time\t$treatment\t$end1\t$end2" >> wt_48_unind_group.txt
fi
if test $sample == Clone1 && test $time == 24 && test $treatment == Induced
then echo -e "$id\t$sample\t$replicate\t$time\t$treatment\t$end1\t$end2" >> clone1_24_ind_group.txt
fi
if test $sample == Clone2 && test $time == 24 && test $treatment == Induced
then echo -e "$id\t$sample\t$replicate\t$time\t$treatment\t$end1\t$end2" >> clone2_24_ind_group.txt
fi
if test $sample == WT && test $time == 24 && test $treatment == Induced
then echo -e "$id\t$sample\t$replicate\t$time\t$treatment\t$end1\t$end2" >> wt_24_ind_group.txt
fi
if test $sample == Clone1 && test $time == 48 && test $treatment == Induced
then echo -e "$id\t$sample\t$replicate\t$time\t$treatment\t$end1\t$end2" >> clone1_48_ind_group.txt
fi
if test $sample == Clone2 && test $time == 48 && test $treatment == Induced
then echo -e "$id\t$sample\t$replicate\t$time\t$treatment\t$end1\t$end2" >> clone2_48_ind_group.txt
fi
if test $sample == WT && test $time == 48 && test $treatment == Induced
then echo -e "$id\t$sample\t$replicate\t$time\t$treatment\t$end1\t$end2" >> wt_48_ind_group.txt
fi
done < "/localdisk/data/BPSM/AY21/fastq/100k.fqfiles" 


for group_file in *group.txt
 do
 echo $group_file
 bam_file_array=()
 while read id sample replicate time treatment end1 end2
 do
 # add the bam files for the samples in the group to an array
 for bam_file in *.sorted.bam
  do
  if test ${end1::13} == ${bam_file::13}
   then
   bam_file_array+=($bam_file)
  fi
 done
 done < $group_file
 echo $bam_file_array

# use the array as input to the bedtools multicov. Sample reads will appear in columns in the same file making determining their mean much easier.
bedtools multicov -bams ${bam_file_array[*]} -bed $bedfile > ${group_file::-4}.counts.tsv

# find the mean of the read data for the groups and paste these into a new file with just the gene names and descriptions
 while read f1 f2 f3 gene_name gene_description sample1 sample2 sample3
 do
 total=$(( sample1+sample2+sample3 ))
 mean=$(echo "scale=2; $total/3" | bc -l)
 echo -e "$gene_name\t$gene_description\t$mean" >> ${group_file::-4}.mean.counts.tsv
 done < ${group_file::-4}.counts.tsv
done


# calculate fold change data
# probably want some sort of user input here as to which two files to compare
while read gene_name gene_description mean
do
while read gene_name_2 gene_description_2 mean_2
do 
if [[ $gene_name == $gene_name_2 ]]
 then
 # Think of a more informative way to announce division by zero.
 if [[ $mean != 0 ]]
  then
  fold_change=$(echo "$mean_2/$mean" | bc -l)
 fi
# then  gene name, descrption and mean_2/mean to a new fold change file
 printf "$gene_name\t$gene_description\t%.2f\n" $fold_change >> fold_change_data.txt
fi
done < second_mean_file
done < first_mean_file

head fold_change_data.txt
#echo ""
#sort -t$'\t' -k3,3nr fold_change_data.txt

